{
  parserClass="org.toitlang.intellij.parser.ToitParser"
  parserUtilClass="org.toitlang.intellij.parser.ToitParserUtil"

  //extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  extends(".*expression")=expression
  psiClassPrefix="Toit"
  psiImplClassSuffix="Impl"
  psiPackage="org.toitlang.intellij.psi"
  psiImplPackage="org.toitlang.intellij.impl"

  elementTypeHolderClass="org.toitlang.intellij.psi.ToitTypes"
  elementTypeClass="org.toitlang.intellij.psi.ToitElementType"
  tokenTypeClass="org.toitlang.intellij.psi.ToitTokenType"

  psiImplUtilClass="org.toitlang.intellij.psi.ToitPsiUtilClass"


  // To get my tokens into ToitToken, is there a cleaner way?
  tokens=[
     COMMENT="COMMENT"
     INDENT_OUT="INDENT_OUT"
     space='regexp:[ \t\f]+'
  ]
}
toitFile ::= toplevel_declarations_* eof_rule

// limited_block_expressino is an expression where a block must be encapsulated in parenthesis as in:
// if (method: it + 3): print 1
private expression_with_limited_block ::= x_expression_with_limited_block

// outer_expression is used in non-expression derived non terminals and keeps tracks of indents
private expression_outer ::= x_expression_outer

external x_expression_outer ::= parseOuterExpression
external x_expression_with_limited_block ::= parseExpressionWithLimitedBlock
external x_parse_guarded_expression ::= parseGuardedExpression
external x_block_expression ::= parseBlockExpression
//external x_previous_was_block ::= parsePreviousImplicitlyClosesStatement
//external x_indent_out_simulate_newline ::= parseIndentOutConvertToNewline
//
//private expression_wrapper ::= expression

private toplevel_declarations_ ::=
  empty |
  import_declaration |
  export_declaration |
  class_declaration |
  interface_declaration |
  function_declaration |
  assigment_declaration

import_declaration ::= IMPORT DOT? qualified_name (AS variable_name)? (SHOW variable_name)? statement_terminator
export_declaration ::= EXPORT (qualified_name | STAR) statement_terminator
class_declaration ::= ABSTRACT? CLASS class_name (EXTENDS qualified_name)? (IMPLEMENTS qualified_name+)?  class_body
{methods=[getName getSuper ]}
interface_declaration ::= INTERFACE class_name (NEWLINE? EXTENDS qualified_name)? interface_body
function_declaration ::= ABSTRACT function_signature statement_terminator | function_signature block
assigment_declaration ::= variable_name type_indicator? assignment_operator expression_outer statement_terminator

class_body ::= COLON (NEWLINE block_start class_declaration_declaration_+ block_terminator | class_declaration_declaration_? statement_terminator)
interface_body ::= COLON (NEWLINE block_start interface_declaration_declarations+ block_terminator | interface_declaration_declarations? statement_terminator)

block_start ::= (INDENT_OUT NEWLINE)? INDENT_IN // The indent out can happens with multiline parameters in method declaration
eof_rule ::= <<eof>>
block_terminator ::= NEWLINE INDENT_OUT | INDENT_OUT | &eof_rule
statement_terminator ::= SEMICOLON |  &(INDENT_OUT | NEWLINE | eof_rule)

private class_declaration_declaration_ ::=
  empty |
  constructor_declaration |
  operator_declaration |
  method_declaration |
  member_declaration

private empty ::= NEWLINE
constructor_declaration ::= CONSTRUCTOR constructor_parameter* block // This falsely parses qualified constructors, but it is ok, we will fix in semantic analysis
operator_declaration ::= OPERATOR overloadable_operator functional_parameter* functional_return_type? block
member_declaration ::= STATIC? variable_name type_indicator? QUESTION? (assignment_operator (expression_outer | QUESTION))? statement_terminator
method_declaration ::= STATIC? function_declaration

private function_signature ::= function_name functional_parameter* functional_return_type?
private multiline_parameter ::= (NEWLINE | INDENT_IN | INDENT_OUT)*
functional_parameter ::= multiline_parameter (parameter_name type_indicator? | LBRACKET parameter_name RBRACKET)  (EQUALS (literal_expression | qualified_parameter))?
functional_return_type ::= multiline_parameter RETURN_TYPE type_name QUESTION?
constructor_parameter ::= multiline_parameter (DOT variable_name | parameter_name) type_indicator? QUESTION? (EQUALS (literal_expression | qualified_parameter))?
type_indicator ::= SLASH type_name

private interface_declaration_declarations ::=
    empty |
    function_signature statement_terminator

block ::= COLON (PIPE variable_name+ PIPE)? (NEWLINE block_start block_statement_+ block_terminator | block_statement_ | &eof_rule)

private block_statement_ ::=
  empty |
  if_statement |
  while_statement |
  for_statement |
  return_statement |
  loop_control |
  assert_statement |
  try_statement |
  expression_outer statement_terminator

try_statement ::= TRY block FINALLY block
loop_control ::= (BREAK | CONTINUE) statement_terminator
return_statement ::= RETURN expression_outer? statement_terminator
assert_statement ::= ASSERT expression_outer statement_terminator
for_statement ::= FOR assignment_expression SEMICOLON expression_outer SEMICOLON expression_with_limited_block block
while_statement ::= WHILE expression_with_limited_block block
if_statement ::= IF expression_with_limited_block block (NEWLINE ELSE IF expression_with_limited_block block)* (NEWLINE ELSE block)?

expression ::= assignment_expression
    | elvis_expression
    | logical_or_expression
    | logical_and_expression
    | logical_not_expression
    | comparison_expression
    | type_expression
    | bitwise_or_expression
    | exponential_expression
    | bitwise_and_expression
    | shift_expression
    | addition_group
    | multiplication_group
    | unary_group
    | postfix_expression
    | indexing_expression
    | qualification_or_call_group
    | primary_group
    {extraRoot=true}

// private rules to define operators with the same priority
private unary_group ::=  unary_minus_expression | bitwise_not_expression
private multiplication_group ::= multiplication_expression | division_expression | remainder_expression
private addition_group ::= addition_expression | subtraction_expression
private primary_group ::= block_expression | simple_reference_or_call_expression | literal_expression | parenthesis_expression
private qualification_or_call_group ::= qualification_call_expression | qualification_expression

// public rules for each expression
assignment_expression ::= expression assignment_operator_nl expression { rightAssociative=true }
elvis_expression ::= expression elvis_question_nl expression_with_limited_block elvis_colon_nl expression
logical_or_expression ::= expression logical_or_operator_nl expression
logical_and_expression ::= expression logical_and_operator_nl expression
logical_not_expression ::= logical_not_operator_nl expression
comparison_expression ::= expression comparison_operator_nl expression
type_expression ::= expression type_operator_nl expression
bitwise_or_expression ::= expression bitwise_or_operator_nl expression
exponential_expression ::= expression (exponential_operator_nl expression) + // N-ary variant, the "(<op> expr ) +" syntax is mandatory.
bitwise_and_expression ::= expression bitwise_and_operator_nl expression
shift_expression ::= expression shift_operator_nl expression

subtraction_expression ::= expression subtraction_operator_nl expression
addition_expression ::= expression addition_operator_nl expression

division_expression ::= expression division_operator_nl expression
multiplication_expression ::= expression multiplication_operator_nl expression
remainder_expression ::= expression remainder_operator_nl expression

unary_minus_expression ::= unary_minus_operator_nl expression
bitwise_not_expression ::= bitwise_not_operator_nl expression

postfix_expression ::= expression postfix_operator_nl
parenthesis_expression ::= &LPAREN nl? LPAREN nl? x_parse_guarded_expression nl? RPAREN

// introduce fake rule with @Nullable qualifier getter and
// let qualified and simple references have its elementType
fake call_or_reference_expression ::= expression? DOT variable_name
simple_reference_or_call_expression ::= (variable_name | primitive_name) arguments | variable_name {extends=call_or_reference_expression elementType=call_or_reference_expression}
qualification_call_expression ::= expression DOT variable_name arguments  {extends=call_or_reference_expression elementType=call_or_reference_expression}
qualification_expression ::= expression DOT variable_name {extends=call_or_reference_expression elementType=call_or_reference_expression}

argument_start_newlining ::= NEWLINE INDENT_IN
argument_stop_newlining ::= block_terminator

non_block_argument ::= !block expression | parameter_name EQUALS !block expression | parameter_name
named_block_argument ::=  parameter_name EQUALS block_expression

arguments ::= non_block_argument* (
    argument_start_newlining ((non_block_argument | named_block_argument) NEWLINE)+ argument_stop_newlining
  | named_block_argument
  | block_expression
)?

indexing_expression ::= expression LBRACKET x_parse_guarded_expression RBRACKET

// wrappers to allow newlines around operators in expressions
external nl ::= parseHandleExpressionNewlineAndIndent
private nli ::= NEWLINE? INDENT_IN?
private assignment_operator_nl ::= &(nli assignment_operator) nl assignment_operator nl
private elvis_question_nl ::= &(nli QUESTION) nl QUESTION nl
private elvis_colon_nl ::= &(nli COLON) nl COLON nl
private logical_or_operator_nl ::= &(nli logical_or_operator) nl logical_or_operator nl
private logical_and_operator_nl ::= &(nli  logical_and_operator) nl logical_and_operator nl
private logical_not_operator_nl ::= logical_not_operator nl
private comparison_operator_nl ::=  &(nli comparison_operator) nl comparison_operator nl
private type_operator_nl ::= &(nli type_operator) nl type_operator nl
private bitwise_or_operator_nl ::= &(nli PIPE) nl PIPE nl
private exponential_operator_nl ::= &(nli HAT) nl HAT nl
private bitwise_and_operator_nl ::= &(nli AMPERSAND) nl AMPERSAND nl
private shift_operator_nl ::= &(nli shift_operator) nl shift_operator nl
private subtraction_operator_nl ::= &(nli MINUS) nl MINUS nl
private addition_operator_nl ::= &(nli PLUS) nl PLUS nl
private division_operator_nl ::= &(nli SLASH) nl SLASH nl
private multiplication_operator_nl ::= &(nli STAR) nl STAR nl
private remainder_operator_nl ::= &(nli PERCENT) nl PERCENT nl
private unary_minus_operator_nl ::= MINUS nl
private bitwise_not_operator_nl ::= TILDE nl
private postfix_operator_nl ::= &(nli postfix_operator) nl postfix_operator



// Literals
list_literal ::= HASH? LBRACKET nl (expression (literal_separator expression)* literal_separator? )? &(nli RBRACKET) nl RBRACKET
set_literal ::= LCURLY nl (expression (literal_separator expression)* literal_separator? )? &(nli RCURLY) nl RCURLY
map_literal ::= LCURLY nl (COLON | (map_entry (literal_separator map_entry)* literal_separator?)) &(nli RCURLY) nl RCURLY

private literal_separator ::= &(nli COMMA) nl COMMA nl
private map_entry ::= expression_with_limited_block &(nli COLON) nl COLON nl expression

literal_expression ::= INTEGER | FLOAT | STRING | CHARACTER | BOOLEAN | NULL | list_literal | map_literal | set_literal
block_expression ::= x_block_expression

// Operator groups
overloadable_operator ::= EQUALS_EQUALS | LBRACKET RBRACKET | SLASH | PLUS | MINUS | PERCENT | STAR | GREATER_OR_EQUALS | GREATER | LESS_OR_EQUALS | LESS | HAT | PIPE | AMPERSAND | TILDE | LBRACKET DOT DOT RBRACKET
assignment_operator ::= DEFINE | CONST_DEFINE | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | REMAINDER_ASSIGN | OR_ASSIGN | NOT_ASSIGN | AND_ASSIGN | SHIFT_LEFT_ASSIGN | SHIFT_RIGHT_ASSIGN | SHIFT_SHIFT_RIGHT_ASSIGN | EQUALS
comparison_operator ::= EQUALS_EQUALS | NOT_EQUALS | LESS | GREATER | LESS_OR_EQUALS | GREATER_OR_EQUALS
logical_and_operator ::= AND | DEPRECATED_AND
logical_or_operator ::= OR | DEPRECATED_OR
logical_not_operator ::= NOT | DEPRECATED_NOT
shift_operator ::= LESS_LESS | LESS_LESS_LESS | GREATER_GREATER
type_operator ::= IS | AS | IS_NOT
postfix_operator ::= PLUS_PLUS | MINUS_MINUS

//
qualified_name ::= variable_name (DOT variable_name)*
qualified_parameter ::= parameter_name (DOT variable_name)*
primitive_name ::= PRIMITIVE (DOT variable_name)+

/* Needed for identifying pieces of the syntax to highlight */
function_name ::= IDENTIFIER
parameter_name ::= IDENTIFIER | MINUS_MINUS_IDENTIFIER
variable_name ::= IDENTIFIER | CONSTRUCTOR | IMPLEMENTS | EXTENDS | OPERATOR | SHOW
type_name ::= IDENTIFIER (DOT IDENTIFIER)* QUESTION?
class_name ::= IDENTIFIER
